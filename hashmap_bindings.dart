// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class RustHashmap {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RustHashmap(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RustHashmap.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Creates a random hashmap and returns a pointer to it.
  ffi.Pointer<ffi.Void> build_hashmap() {
    return _build_hashmap();
  }

  late final _build_hashmapPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'build_hashmap');
  late final _build_hashmap =
      _build_hashmapPtr.asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// Gets a value from the hashmap.
  /// Returns null if the key is not found, or the pointer to the value.
  ffi.Pointer<ffi.Void> get_hashmap_value(
    ffi.Pointer<ffi.Void> pointer,
    int key,
  ) {
    return _get_hashmap_value(
      pointer,
      key,
    );
  }

  late final _get_hashmap_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('get_hashmap_value');
  late final _get_hashmap_value = _get_hashmap_valuePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Frees the hashmap.
  void free_hashmap(
    ffi.Pointer<ffi.Void> pointer,
  ) {
    return _free_hashmap(
      pointer,
    );
  }

  late final _free_hashmapPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free_hashmap');
  late final _free_hashmap =
      _free_hashmapPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Frees the Foo struct.
  void free_foo(
    ffi.Pointer<ffi.Void> pointer,
  ) {
    return _free_foo(
      pointer,
    );
  }

  late final _free_fooPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free_foo');
  late final _free_foo =
      _free_fooPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
}

class Bar extends ffi.Struct {
  @ffi.Int()
  external int x;

  @ffi.Int()
  external int y;
}

class Foo extends ffi.Struct {
  @ffi.Int()
  external int x;

  external Bar y;
}
